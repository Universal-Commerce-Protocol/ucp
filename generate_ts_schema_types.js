const fs = require('node:fs');
const path = require('node:path');
const { compile } = require('json-schema-to-typescript');

const SOURCE_ROOT = path.resolve(__dirname, 'source');
const OUTPUT_FILE = path.resolve(__dirname, './generated/schema-types.ts');
const WRAPPER_NAME = 'SCHEMA_WRAPPER';

/**
 * Dynamically finds all JSON schemas and generates TypeScript types.
 */
async function generate() {
  if (!fs.existsSync(path.dirname(OUTPUT_FILE))) {
    fs.mkdirSync(path.dirname(OUTPUT_FILE), {recursive: true});
  }

  const properties = {};

  const addSchemasFromDir = (dir, prefix = '') => {
    if (fs.existsSync(dir)) {
      for (const file of fs.readdirSync(dir)) {
        const fullPath = path.join(dir, file);
        const stat = fs.statSync(fullPath);
        if (stat.isDirectory()) {
          // Skip types directory as they are pulled in by refs
          continue;
        } else if (file.endsWith('.json')) {
          const name = (prefix + path.basename(file, '.json')).replace(/[-.]/g, '_');
          properties[name] = { $ref: fullPath };
        }
      }
    }
  };

  // Add core schemas
  addSchemasFromDir(path.join(SOURCE_ROOT, 'schemas'));
  // Add transport schemas
  addSchemasFromDir(path.join(SOURCE_ROOT, 'schemas/transports'), 'transport_');
  // Add shopping schemas
  addSchemasFromDir(path.join(SOURCE_ROOT, 'schemas/shopping'));
  // Add discovery schemas
  addSchemasFromDir(path.join(SOURCE_ROOT, 'discovery'));

  // Add handler schemas
  const handlersDir = path.join(SOURCE_ROOT, 'handlers');
  if (fs.existsSync(handlersDir)) {
    for (const handler of fs.readdirSync(handlersDir)) {
      const handlerPath = path.join(handlersDir, handler);
      if (fs.statSync(handlerPath).isDirectory()) {
        addSchemasFromDir(handlerPath, `${handler}_`);
      }
    }
  }

  // Add service schemas
  const servicesDir = path.join(SOURCE_ROOT, 'services');
  if (fs.existsSync(servicesDir)) {
    for (const service of fs.readdirSync(servicesDir)) {
      const servicePath = path.join(servicesDir, service);
      if (fs.statSync(servicePath).isDirectory()) {
        addSchemasFromDir(servicePath, `${service}_`);
      }
    }
  }

  console.log(`Found ${Object.keys(properties).length} schemas. Compiling...`);

  const wrappedSchema = {
    title: WRAPPER_NAME,
    type: 'object',
    properties,
    additionalProperties: false
  };

  try {
    let ts = await compile(wrappedSchema, WRAPPER_NAME, {
      cwd: SOURCE_ROOT,
      $refOptions: {
        resolve: {
          file: {
            order: 1,
            canRead: true,
            read: (file) => {
              let filePath = file.url;
              if (filePath.startsWith('file://')) {
                try {
                  filePath = require('node:url').fileURLToPath(filePath);
                } catch {
                  filePath = filePath.replace('file://', '');
                }
              }

              const content = fs.readFileSync(filePath, 'utf8');
              const json = JSON.parse(content);
              /**
               * Cleans up the JSON object by removing properties that interfere
               * with `json-schema-to-typescript`.
               * This function mutates the input object. While acceptable here,
               * be mindful of side effects. If this JSON object were used
               * elsewhere, this could lead to unexpected behavior.
               * @param {!any} obj The object to clean.
               */
              function clean(obj) {
                if (typeof obj !== 'object' || obj === null) return;

                // When $ref is present, other properties like title and
                // description are technically ignored in older JSON Schema
                // drafts. We remove them here to prevent
                // json-schema-to-typescript from generating duplicate interface
                // definitions or JSDoc comments that conflict with the
                // referenced type.
                if (obj.$ref) {
                  delete obj.description;
                  delete obj.title;
                }

                for (const key in obj) {
                  clean(obj[key]);
                }
              }

              clean(json);
              return json;
            }
          }
        }
      },
      bannerComment: `
/* tslint:disable:enforce-comments-on-exported-symbols */
/* eslint-disable */
/* tslint:disable:enforce-name-casing */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
`,
      style: {singleQuote: true, bracketSpacing: true},
      declareExternallyReferenced: true,
      enableConstEnums: false,
      unreachableDefinitions: true,
      strictIndexSignatures: false
    });

    // Cleanup: Remove the wrapper interface and convert to 'export declare interface'
    // We use \n} to match the closing brace at the start of a line to avoid matching nested braces
    const wrapperRegex = new RegExp(`export interface ${WRAPPER_NAME}\\s*\\{[\\s\\S]*?\\n\\}\\s*`, 'g');
    ts = ts.replace(wrapperRegex, '')
           .replace(/export interface/g, 'export declare interface');

    // Replace (A | B)[] with Array<A | B>
    ts = ts.replace(/:\s*\(([^)]+)\)\[\]/g, ': Array<$1>');
    // Replace { ... }[] with Array<{ ... }>
    ts = ts.replace(/:\s*(\{[^}]+\})\[\]/g, ': Array<$1>');

    fs.writeFileSync(OUTPUT_FILE, ts.trim());
    console.log(`Success! Types written to ${OUTPUT_FILE}`);
  } catch (err) {
    console.error('Error generating types:', err);
  }
}

generate();
